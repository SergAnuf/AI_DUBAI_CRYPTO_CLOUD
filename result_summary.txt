============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.3.5, pluggy-1.6.0
testmon: The packages installed in your Python environment have been changed. All tests have to be re-executed. environment: default
rootdir: /home/zcemg08/projects/chatbot
plugins: Faker-19.13.0, testmon-2.1.3, langsmith-0.3.42, anyio-4.9.0
collected 100 items

tests/test_agent.py ....F.......F......F......F.................F...F.F. [ 52%]
.................F.....F......F....F...F......FF                         [100%]

=================================== FAILURES ===================================
___________________________ test_main_agent[line_5] ____________________________

self = Index(['bedrooms', 'count'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'create pie chart of properties available in Ajman, grouped by the number of rooms'
query_id = 'line_5'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['bedrooms', 'count'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'create pie chart of properties available in Ajman, grouped by the number of rooms'
query_id = 'line_5'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create pie chart of properties available in Ajman, grouped by the number of rooms

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
geospatial_plot
___________________________ test_main_agent[line_13] ___________________________

self = Index(['City', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'where is a 1 bedroom flat cheaper on average: Umm Al Quwain or Sharjah?'
query_id = 'line_13'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['City', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'where is a 1 bedroom flat cheaper on average: Umm Al Quwain or Sharjah?'
query_id = 'line_13'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: where is a 1 bedroom flat cheaper on average: Umm Al Quwain or Sharjah?

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
            City  Average Price
0  Umm Al Quwain            NaN
1        Sharjah  827333.333333
geospatial_plot
___________________________ test_main_agent[line_20] ___________________________

self = Index(['bedrooms', 'count'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'create pie chart of properties available in Dubai Marina, grouped by the number of rooms'
query_id = 'line_20'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['bedrooms', 'count'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'create pie chart of properties available in Dubai Marina, grouped by the number of rooms'
query_id = 'line_20'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create pie chart of properties available in Dubai Marina, grouped by the number of rooms

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
geospatial_plot
___________________________ test_main_agent[line_27] ___________________________

query = 'create time series plot of the number of properties added in Dubai per month'
query_id = 'line_27'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:21: in main_agent
    result = visualize_tool.invoke({"data": data, "query": query})
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:513: in invoke
    return self.run(tool_input, **kwargs)
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:774: in run
    raise error_to_raise
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:736: in run
    tool_args, tool_kwargs = self._to_args_and_kwargs(
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:651: in _to_args_and_kwargs
    tool_input = self._parse_input(tool_input, tool_call_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StructuredTool(name='visualize_tool', description='Generate visualizations for the Dubai property dataset using Plotly..., args_schema=<class 'langchain_core.utils.pydantic.visualize_tool'>, func=<function visualize_tool at 0x748bba723880>)
tool_input = {'data': None, 'query': 'create time series plot of the number of properties added in Dubai per month'}
tool_call_id = None

    def _parse_input(
        self, tool_input: Union[str, dict], tool_call_id: Optional[str]
    ) -> Union[str, dict[str, Any]]:
        """Convert tool input to a pydantic model.
    
        Args:
            tool_input: The input to the tool.
            tool_call_id: The id of the tool call.
        """
        input_args = self.args_schema
        if isinstance(tool_input, str):
            if input_args is not None:
                if isinstance(input_args, dict):
                    msg = (
                        "String tool inputs are not allowed when "
                        "using tools with JSON schema args_schema."
                    )
                    raise ValueError(msg)
                key_ = next(iter(get_fields(input_args).keys()))
                if hasattr(input_args, "model_validate"):
                    input_args.model_validate({key_: tool_input})
                else:
                    input_args.parse_obj({key_: tool_input})
            return tool_input
        if input_args is not None:
            if isinstance(input_args, dict):
                return tool_input
            if issubclass(input_args, BaseModel):
                for k, v in get_all_basemodel_annotations(input_args).items():
                    if (
                        _is_injected_arg_type(v, injected_type=InjectedToolCallId)
                        and k not in tool_input
                    ):
                        if tool_call_id is None:
                            msg = (
                                "When tool includes an InjectedToolCallId "
                                "argument, tool must always be invoked with a full "
                                "model ToolCall of the form: {'args': {...}, "
                                "'name': '...', 'type': 'tool_call', "
                                "'tool_call_id': '...'}"
                            )
                            raise ValueError(msg)
                        tool_input[k] = tool_call_id
>               result = input_args.model_validate(tool_input)
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for visualize_tool
E               data
E                 Input should be a valid list [type=list_type, input_value=None, input_type=NoneType]
E                   For further information visit https://errors.pydantic.dev/2.11/v/list_type

.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:570: ValidationError

During handling of the above exception, another exception occurred:

query = 'create time series plot of the number of properties added in Dubai per month'
query_id = 'line_27'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create time series plot of the number of properties added in Dubai per month

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
plot_stats
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/generate_chat_pipeline.py", line 335, in run
    ).run(input)
      ^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 137, in run
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 101, in run
    step_output = logic.execute(
                  ^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 133, in execute
    {"content_type": "response", "value": ResponseSerializer.serialize(result)},
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/responses/response_serializer.py", line 27, in serialize
    df_dict = ResponseSerializer.serialize_dataframe(result["value"])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/responses/response_serializer.py", line 11, in serialize_dataframe
    json_data = json.loads(df.to_json(orient="split", date_format="iso"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/util/_decorators.py", line 333, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/core/generic.py", line 2702, in to_json
    return json.to_json(
           ^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/io/json/_json.py", line 210, in to_json
    ).write()
      ^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/io/json/_json.py", line 263, in write
    return ujson_dumps(
           ^^^^^^^^^^^^
OverflowError: Maximum recursion level reached
------------------------------ Captured log call -------------------------------
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 12, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_matplotlib.py", line 75, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedMatplotlib")
AttributeError: 'tight_layout' is not allowed in RestrictedMatplotlib

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 1]
ERROR    pandasai.helpers.logger:logger.py:80 Pipeline failed on step 6: Maximum recursion level reached
___________________________ test_main_agent[line_45] ___________________________

query = 'create time series plot of the number of properties added in Fujairah per month'
query_id = 'line_45'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:21: in main_agent
    result = visualize_tool.invoke({"data": data, "query": query})
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:513: in invoke
    return self.run(tool_input, **kwargs)
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:774: in run
    raise error_to_raise
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:736: in run
    tool_args, tool_kwargs = self._to_args_and_kwargs(
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:651: in _to_args_and_kwargs
    tool_input = self._parse_input(tool_input, tool_call_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StructuredTool(name='visualize_tool', description='Generate visualizations for the Dubai property dataset using Plotly..., args_schema=<class 'langchain_core.utils.pydantic.visualize_tool'>, func=<function visualize_tool at 0x748bba723880>)
tool_input = {'data': None, 'query': 'create time series plot of the number of properties added in Fujairah per month'}
tool_call_id = None

    def _parse_input(
        self, tool_input: Union[str, dict], tool_call_id: Optional[str]
    ) -> Union[str, dict[str, Any]]:
        """Convert tool input to a pydantic model.
    
        Args:
            tool_input: The input to the tool.
            tool_call_id: The id of the tool call.
        """
        input_args = self.args_schema
        if isinstance(tool_input, str):
            if input_args is not None:
                if isinstance(input_args, dict):
                    msg = (
                        "String tool inputs are not allowed when "
                        "using tools with JSON schema args_schema."
                    )
                    raise ValueError(msg)
                key_ = next(iter(get_fields(input_args).keys()))
                if hasattr(input_args, "model_validate"):
                    input_args.model_validate({key_: tool_input})
                else:
                    input_args.parse_obj({key_: tool_input})
            return tool_input
        if input_args is not None:
            if isinstance(input_args, dict):
                return tool_input
            if issubclass(input_args, BaseModel):
                for k, v in get_all_basemodel_annotations(input_args).items():
                    if (
                        _is_injected_arg_type(v, injected_type=InjectedToolCallId)
                        and k not in tool_input
                    ):
                        if tool_call_id is None:
                            msg = (
                                "When tool includes an InjectedToolCallId "
                                "argument, tool must always be invoked with a full "
                                "model ToolCall of the form: {'args': {...}, "
                                "'name': '...', 'type': 'tool_call', "
                                "'tool_call_id': '...'}"
                            )
                            raise ValueError(msg)
                        tool_input[k] = tool_call_id
>               result = input_args.model_validate(tool_input)
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for visualize_tool
E               data
E                 Input should be a valid list [type=list_type, input_value=None, input_type=NoneType]
E                   For further information visit https://errors.pydantic.dev/2.11/v/list_type

.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:570: ValidationError

During handling of the above exception, another exception occurred:

query = 'create time series plot of the number of properties added in Fujairah per month'
query_id = 'line_45'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create time series plot of the number of properties added in Fujairah per month

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
plot_stats
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/generate_chat_pipeline.py", line 335, in run
    ).run(input)
      ^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 137, in run
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 101, in run
    step_output = logic.execute(
                  ^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 133, in execute
    {"content_type": "response", "value": ResponseSerializer.serialize(result)},
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/responses/response_serializer.py", line 27, in serialize
    df_dict = ResponseSerializer.serialize_dataframe(result["value"])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/responses/response_serializer.py", line 11, in serialize_dataframe
    json_data = json.loads(df.to_json(orient="split", date_format="iso"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/util/_decorators.py", line 333, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/core/generic.py", line 2702, in to_json
    return json.to_json(
           ^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/io/json/_json.py", line 210, in to_json
    ).write()
      ^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/io/json/_json.py", line 263, in write
    return ujson_dumps(
           ^^^^^^^^^^^^
OverflowError: Maximum recursion level reached
------------------------------ Captured log call -------------------------------
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 11, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_matplotlib.py", line 75, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedMatplotlib")
AttributeError: 'tight_layout' is not allowed in RestrictedMatplotlib

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 1]
ERROR    pandasai.helpers.logger:logger.py:80 Pipeline failed on step 6: Maximum recursion level reached
___________________________ test_main_agent[line_49] ___________________________

query = 'create time series plot of the number of properties added in Emirates Hills per month'
query_id = 'line_49'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:21: in main_agent
    result = visualize_tool.invoke({"data": data, "query": query})
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:513: in invoke
    return self.run(tool_input, **kwargs)
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:774: in run
    raise error_to_raise
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:736: in run
    tool_args, tool_kwargs = self._to_args_and_kwargs(
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:651: in _to_args_and_kwargs
    tool_input = self._parse_input(tool_input, tool_call_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StructuredTool(name='visualize_tool', description='Generate visualizations for the Dubai property dataset using Plotly..., args_schema=<class 'langchain_core.utils.pydantic.visualize_tool'>, func=<function visualize_tool at 0x748bba723880>)
tool_input = {'data': None, 'query': 'create time series plot of the number of properties added in Emirates Hills per month'}
tool_call_id = None

    def _parse_input(
        self, tool_input: Union[str, dict], tool_call_id: Optional[str]
    ) -> Union[str, dict[str, Any]]:
        """Convert tool input to a pydantic model.
    
        Args:
            tool_input: The input to the tool.
            tool_call_id: The id of the tool call.
        """
        input_args = self.args_schema
        if isinstance(tool_input, str):
            if input_args is not None:
                if isinstance(input_args, dict):
                    msg = (
                        "String tool inputs are not allowed when "
                        "using tools with JSON schema args_schema."
                    )
                    raise ValueError(msg)
                key_ = next(iter(get_fields(input_args).keys()))
                if hasattr(input_args, "model_validate"):
                    input_args.model_validate({key_: tool_input})
                else:
                    input_args.parse_obj({key_: tool_input})
            return tool_input
        if input_args is not None:
            if isinstance(input_args, dict):
                return tool_input
            if issubclass(input_args, BaseModel):
                for k, v in get_all_basemodel_annotations(input_args).items():
                    if (
                        _is_injected_arg_type(v, injected_type=InjectedToolCallId)
                        and k not in tool_input
                    ):
                        if tool_call_id is None:
                            msg = (
                                "When tool includes an InjectedToolCallId "
                                "argument, tool must always be invoked with a full "
                                "model ToolCall of the form: {'args': {...}, "
                                "'name': '...', 'type': 'tool_call', "
                                "'tool_call_id': '...'}"
                            )
                            raise ValueError(msg)
                        tool_input[k] = tool_call_id
>               result = input_args.model_validate(tool_input)
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for visualize_tool
E               data
E                 Input should be a valid list [type=list_type, input_value=None, input_type=NoneType]
E                   For further information visit https://errors.pydantic.dev/2.11/v/list_type

.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:570: ValidationError

During handling of the above exception, another exception occurred:

query = 'create time series plot of the number of properties added in Emirates Hills per month'
query_id = 'line_49'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create time series plot of the number of properties added in Emirates Hills per month

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
plot_stats
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/generate_chat_pipeline.py", line 335, in run
    ).run(input)
      ^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 137, in run
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 101, in run
    step_output = logic.execute(
                  ^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 113, in execute
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]
------------------------------ Captured log call -------------------------------
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 7, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_core.py", line 1030, in __call__
    return plot_backend.plot(data, kind=kind, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_matplotlib/__init__.py", line 71, in plot
    plot_obj.generate()
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_matplotlib/core.py", line 508, in generate
    self._post_plot_logic(ax, self.data)
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_matplotlib/core.py", line 1972, in _post_plot_logic
    s_edge = self.ax_pos[0] - 0.25 + self.lim_offset
             ~~~~~~~~~~~^^^
IndexError: index 0 is out of bounds for axis 0 with size 0

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 1]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 2]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 3]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]

ERROR    pandasai.helpers.logger:logger.py:80 Pipeline failed on step 6: ["result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]
___________________________ test_main_agent[line_51] ___________________________

query = 'make bar plot of the average property prices in Palm Jumeirah by the number of rooms'
query_id = 'line_51'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:21: in main_agent
    result = visualize_tool.invoke({"data": data, "query": query})
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:513: in invoke
    return self.run(tool_input, **kwargs)
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:774: in run
    raise error_to_raise
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:736: in run
    tool_args, tool_kwargs = self._to_args_and_kwargs(
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:651: in _to_args_and_kwargs
    tool_input = self._parse_input(tool_input, tool_call_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StructuredTool(name='visualize_tool', description='Generate visualizations for the Dubai property dataset using Plotly..., args_schema=<class 'langchain_core.utils.pydantic.visualize_tool'>, func=<function visualize_tool at 0x748bba723880>)
tool_input = {'data': None, 'query': 'make bar plot of the average property prices in Palm Jumeirah by the number of rooms'}
tool_call_id = None

    def _parse_input(
        self, tool_input: Union[str, dict], tool_call_id: Optional[str]
    ) -> Union[str, dict[str, Any]]:
        """Convert tool input to a pydantic model.
    
        Args:
            tool_input: The input to the tool.
            tool_call_id: The id of the tool call.
        """
        input_args = self.args_schema
        if isinstance(tool_input, str):
            if input_args is not None:
                if isinstance(input_args, dict):
                    msg = (
                        "String tool inputs are not allowed when "
                        "using tools with JSON schema args_schema."
                    )
                    raise ValueError(msg)
                key_ = next(iter(get_fields(input_args).keys()))
                if hasattr(input_args, "model_validate"):
                    input_args.model_validate({key_: tool_input})
                else:
                    input_args.parse_obj({key_: tool_input})
            return tool_input
        if input_args is not None:
            if isinstance(input_args, dict):
                return tool_input
            if issubclass(input_args, BaseModel):
                for k, v in get_all_basemodel_annotations(input_args).items():
                    if (
                        _is_injected_arg_type(v, injected_type=InjectedToolCallId)
                        and k not in tool_input
                    ):
                        if tool_call_id is None:
                            msg = (
                                "When tool includes an InjectedToolCallId "
                                "argument, tool must always be invoked with a full "
                                "model ToolCall of the form: {'args': {...}, "
                                "'name': '...', 'type': 'tool_call', "
                                "'tool_call_id': '...'}"
                            )
                            raise ValueError(msg)
                        tool_input[k] = tool_call_id
>               result = input_args.model_validate(tool_input)
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for visualize_tool
E               data
E                 Input should be a valid list [type=list_type, input_value=None, input_type=NoneType]
E                   For further information visit https://errors.pydantic.dev/2.11/v/list_type

.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:570: ValidationError

During handling of the above exception, another exception occurred:

query = 'make bar plot of the average property prices in Palm Jumeirah by the number of rooms'
query_id = 'line_51'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: make bar plot of the average property prices in Palm Jumeirah by the number of rooms

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
plot_stats
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/generate_chat_pipeline.py", line 335, in run
    ).run(input)
      ^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 137, in run
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 101, in run
    step_output = logic.execute(
                  ^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 113, in execute
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 3, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_pandas.py", line 109, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedPandas")
AttributeError: 'to_numeric' is not allowed in RestrictedPandas
------------------------------ Captured log call -------------------------------
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 3, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_pandas.py", line 109, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedPandas")
AttributeError: 'to_numeric' is not allowed in RestrictedPandas

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 1]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 3, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_pandas.py", line 109, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedPandas")
AttributeError: 'to_numeric' is not allowed in RestrictedPandas

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 2]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 3, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_pandas.py", line 109, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedPandas")
AttributeError: 'to_numeric' is not allowed in RestrictedPandas

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 3]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 3, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_pandas.py", line 109, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedPandas")
AttributeError: 'to_numeric' is not allowed in RestrictedPandas

ERROR    pandasai.helpers.logger:logger.py:80 Pipeline failed on step 6: 'to_numeric' is not allowed in RestrictedPandas
___________________________ test_main_agent[line_70] ___________________________

query = 'create time series plot of the number of properties added in Dubai per month'
query_id = 'line_70'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:21: in main_agent
    result = visualize_tool.invoke({"data": data, "query": query})
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:513: in invoke
    return self.run(tool_input, **kwargs)
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:774: in run
    raise error_to_raise
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:736: in run
    tool_args, tool_kwargs = self._to_args_and_kwargs(
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:651: in _to_args_and_kwargs
    tool_input = self._parse_input(tool_input, tool_call_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StructuredTool(name='visualize_tool', description='Generate visualizations for the Dubai property dataset using Plotly..., args_schema=<class 'langchain_core.utils.pydantic.visualize_tool'>, func=<function visualize_tool at 0x748bba723880>)
tool_input = {'data': None, 'query': 'create time series plot of the number of properties added in Dubai per month'}
tool_call_id = None

    def _parse_input(
        self, tool_input: Union[str, dict], tool_call_id: Optional[str]
    ) -> Union[str, dict[str, Any]]:
        """Convert tool input to a pydantic model.
    
        Args:
            tool_input: The input to the tool.
            tool_call_id: The id of the tool call.
        """
        input_args = self.args_schema
        if isinstance(tool_input, str):
            if input_args is not None:
                if isinstance(input_args, dict):
                    msg = (
                        "String tool inputs are not allowed when "
                        "using tools with JSON schema args_schema."
                    )
                    raise ValueError(msg)
                key_ = next(iter(get_fields(input_args).keys()))
                if hasattr(input_args, "model_validate"):
                    input_args.model_validate({key_: tool_input})
                else:
                    input_args.parse_obj({key_: tool_input})
            return tool_input
        if input_args is not None:
            if isinstance(input_args, dict):
                return tool_input
            if issubclass(input_args, BaseModel):
                for k, v in get_all_basemodel_annotations(input_args).items():
                    if (
                        _is_injected_arg_type(v, injected_type=InjectedToolCallId)
                        and k not in tool_input
                    ):
                        if tool_call_id is None:
                            msg = (
                                "When tool includes an InjectedToolCallId "
                                "argument, tool must always be invoked with a full "
                                "model ToolCall of the form: {'args': {...}, "
                                "'name': '...', 'type': 'tool_call', "
                                "'tool_call_id': '...'}"
                            )
                            raise ValueError(msg)
                        tool_input[k] = tool_call_id
>               result = input_args.model_validate(tool_input)
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for visualize_tool
E               data
E                 Input should be a valid list [type=list_type, input_value=None, input_type=NoneType]
E                   For further information visit https://errors.pydantic.dev/2.11/v/list_type

.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:570: ValidationError

During handling of the above exception, another exception occurred:

query = 'create time series plot of the number of properties added in Dubai per month'
query_id = 'line_70'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create time series plot of the number of properties added in Dubai per month

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
plot_stats
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/generate_chat_pipeline.py", line 335, in run
    ).run(input)
      ^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 137, in run
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 101, in run
    step_output = logic.execute(
                  ^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 133, in execute
    {"content_type": "response", "value": ResponseSerializer.serialize(result)},
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/responses/response_serializer.py", line 27, in serialize
    df_dict = ResponseSerializer.serialize_dataframe(result["value"])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/responses/response_serializer.py", line 11, in serialize_dataframe
    json_data = json.loads(df.to_json(orient="split", date_format="iso"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/util/_decorators.py", line 333, in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/core/generic.py", line 2702, in to_json
    return json.to_json(
           ^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/io/json/_json.py", line 210, in to_json
    ).write()
      ^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/io/json/_json.py", line 263, in write
    return ujson_dumps(
           ^^^^^^^^^^^^
OverflowError: Maximum recursion level reached
------------------------------ Captured log call -------------------------------
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 12, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/restricted_matplotlib.py", line 75, in __getattr__
    raise AttributeError(f"'{name}' is not allowed in RestrictedMatplotlib")
AttributeError: 'tight_layout' is not allowed in RestrictedMatplotlib

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 1]
ERROR    pandasai.helpers.logger:logger.py:80 Pipeline failed on step 6: Maximum recursion level reached
___________________________ test_main_agent[line_76] ___________________________

self = Index(['City', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'where is a 4 bedroom flat cheaper on average: Ras Al Khaimah or Umm Al Quwain?'
query_id = 'line_76'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['City', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'where is a 4 bedroom flat cheaper on average: Ras Al Khaimah or Umm Al Quwain?'
query_id = 'line_76'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: where is a 4 bedroom flat cheaper on average: Ras Al Khaimah or Umm Al Quwain?

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
             City Average Price
0  Ras Al Khaimah          None
1   Umm Al Quwain          None
geospatial_plot
___________________________ test_main_agent[line_83] ___________________________

self = Index(['count'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'create pie chart of properties available in Fujairah, grouped by the number of rooms'
query_id = 'line_83'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['count'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'create pie chart of properties available in Fujairah, grouped by the number of rooms'
query_id = 'line_83'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create pie chart of properties available in Fujairah, grouped by the number of rooms

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
geospatial_plot
___________________________ test_main_agent[line_88] ___________________________

query = 'create time series plot of the number of properties added in Emirates Hills per month'
query_id = 'line_88'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:21: in main_agent
    result = visualize_tool.invoke({"data": data, "query": query})
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:513: in invoke
    return self.run(tool_input, **kwargs)
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:774: in run
    raise error_to_raise
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:736: in run
    tool_args, tool_kwargs = self._to_args_and_kwargs(
.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:651: in _to_args_and_kwargs
    tool_input = self._parse_input(tool_input, tool_call_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StructuredTool(name='visualize_tool', description='Generate visualizations for the Dubai property dataset using Plotly..., args_schema=<class 'langchain_core.utils.pydantic.visualize_tool'>, func=<function visualize_tool at 0x748bba723880>)
tool_input = {'data': None, 'query': 'create time series plot of the number of properties added in Emirates Hills per month'}
tool_call_id = None

    def _parse_input(
        self, tool_input: Union[str, dict], tool_call_id: Optional[str]
    ) -> Union[str, dict[str, Any]]:
        """Convert tool input to a pydantic model.
    
        Args:
            tool_input: The input to the tool.
            tool_call_id: The id of the tool call.
        """
        input_args = self.args_schema
        if isinstance(tool_input, str):
            if input_args is not None:
                if isinstance(input_args, dict):
                    msg = (
                        "String tool inputs are not allowed when "
                        "using tools with JSON schema args_schema."
                    )
                    raise ValueError(msg)
                key_ = next(iter(get_fields(input_args).keys()))
                if hasattr(input_args, "model_validate"):
                    input_args.model_validate({key_: tool_input})
                else:
                    input_args.parse_obj({key_: tool_input})
            return tool_input
        if input_args is not None:
            if isinstance(input_args, dict):
                return tool_input
            if issubclass(input_args, BaseModel):
                for k, v in get_all_basemodel_annotations(input_args).items():
                    if (
                        _is_injected_arg_type(v, injected_type=InjectedToolCallId)
                        and k not in tool_input
                    ):
                        if tool_call_id is None:
                            msg = (
                                "When tool includes an InjectedToolCallId "
                                "argument, tool must always be invoked with a full "
                                "model ToolCall of the form: {'args': {...}, "
                                "'name': '...', 'type': 'tool_call', "
                                "'tool_call_id': '...'}"
                            )
                            raise ValueError(msg)
                        tool_input[k] = tool_call_id
>               result = input_args.model_validate(tool_input)
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for visualize_tool
E               data
E                 Input should be a valid list [type=list_type, input_value=None, input_type=NoneType]
E                   For further information visit https://errors.pydantic.dev/2.11/v/list_type

.chatbot_env/lib/python3.12/site-packages/langchain_core/tools/base.py:570: ValidationError

During handling of the above exception, another exception occurred:

query = 'create time series plot of the number of properties added in Emirates Hills per month'
query_id = 'line_88'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: create time series plot of the number of properties added in Emirates Hills per month

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
plot_stats
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/generate_chat_pipeline.py", line 335, in run
    ).run(input)
      ^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 137, in run
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/pipeline.py", line 101, in run
    step_output = logic.execute(
                  ^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 113, in execute
    raise e
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["The result dict contains inappropriate 'type'. Expected 'dataframe', actual 'message'.", "result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]
------------------------------ Captured log call -------------------------------
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 85, in execute
    result = self.execute_code(code_to_run, code_context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 174, in execute_code
    exec(code, environment)
  File "<string>", line 7, in <module>
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_core.py", line 1030, in __call__
    return plot_backend.plot(data, kind=kind, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_matplotlib/__init__.py", line 71, in plot
    plot_obj.generate()
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_matplotlib/core.py", line 508, in generate
    self._post_plot_logic(ax, self.data)
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandas/plotting/_matplotlib/core.py", line 1972, in _post_plot_logic
    s_edge = self.ax_pos[0] - 0.25 + self.lim_offset
             ~~~~~~~~~~~^^^
IndexError: index 0 is out of bounds for axis 0 with size 0

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 1]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["The result dict contains inappropriate 'type'. Expected 'dataframe', actual 'message'.", "result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 2]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["The result dict contains inappropriate 'type'. Expected 'dataframe', actual 'message'.", "result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]

WARNING  pandasai.helpers.logger:logger.py:78 Failed to execute code retrying with a correction framework [retry number: 3]
ERROR    pandasai.helpers.logger:logger.py:80 Failed with error: Traceback (most recent call last):
  File "/home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_execution.py", line 94, in execute
    raise InvalidLLMOutputType(validation_errors)
pandasai.exceptions.InvalidLLMOutputType: ["The result dict contains inappropriate 'type'. Expected 'dataframe', actual 'message'.", "result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]

ERROR    pandasai.helpers.logger:logger.py:80 Pipeline failed on step 6: ["The result dict contains inappropriate 'type'. Expected 'dataframe', actual 'message'.", "result value 'No properties found in Emirates Hills.' seems to be inappropriate for the type 'dataframe'."]
___________________________ test_main_agent[line_92] ___________________________

self = Index(['Location', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'where is a 4 bedroom flat cheaper on average: Palm Jumeirah or Abu Dhabi?'
query_id = 'line_92'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['Location', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'where is a 4 bedroom flat cheaper on average: Palm Jumeirah or Abu Dhabi?'
query_id = 'line_92'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: where is a 4 bedroom flat cheaper on average: Palm Jumeirah or Abu Dhabi?

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
geospatial_plot
___________________________ test_main_agent[line_99] ___________________________

self = Index(['Location', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'where is a 2 bedroom flat cheaper on average: Emirates Hills or Palm Jumeirah?'
query_id = 'line_99'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['Location', 'Average Price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'where is a 2 bedroom flat cheaper on average: Emirates Hills or Palm Jumeirah?'
query_id = 'line_99'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: where is a 2 bedroom flat cheaper on average: Emirates Hills or Palm Jumeirah?

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
{'type': 'dataframe', 'value':          Location  Average Price
0  Emirates Hills            NaN
1   Palm Jumeirah   8.055555e+06}
geospatial_plot
__________________________ test_main_agent[line_100] ___________________________

self = Index(['City', 'price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'latitude'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

query = 'where is a 2 bedroom flat cheaper on average: Sharjah or Umm Al Quwain?'
query_id = 'line_100'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
>           result = main_agent(query)

tests/test_agent.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/agent.py:25: in main_agent
    result = generate_google_maps_html(data)
src/geo_tools.py:57: in generate_google_maps_html
    position: {{ lat: {row['latitude']}, lng: {row['longitude']} }},
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1121: in __getitem__
    return self._get_value(key)
.chatbot_env/lib/python3.12/site-packages/pandas/core/series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['City', 'price'], dtype='object'), key = 'latitude'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'latitude'

.chatbot_env/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

query = 'where is a 2 bedroom flat cheaper on average: Sharjah or Umm Al Quwain?'
query_id = 'line_100'

    @pytest.mark.parametrize("query,query_id", queries, ids=[qid for _, qid in queries])
    def test_main_agent(query, query_id):
        try:
            result = main_agent(query)
            assert result is not None
        except Exception as e:
>           pytest.fail(f"Failed: {query}")
E           Failed: Failed: where is a 2 bedroom flat cheaper on average: Sharjah or Umm Al Quwain?

tests/test_agent.py:19: Failed
----------------------------- Captured stdout call -----------------------------
{'type': 'dataframe', 'value':       City         price
0  Sharjah  1.164663e+06}
geospatial_plot
=============================== warnings summary ===============================
.chatbot_env/lib/python3.12/site-packages/pydantic/_internal/_config.py:323
.chatbot_env/lib/python3.12/site-packages/pydantic/_internal/_config.py:323
  /home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

.chatbot_env/lib/python3.12/site-packages/astor/op_util.py:92
  /home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/astor/op_util.py:92: DeprecationWarning: ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead
    precedence_data = dict((getattr(ast, x, None), z) for x, y, z in op_data)

tests/test_agent.py::test_main_agent[line_1]
  /home/zcemg08/projects/chatbot/src/agent.py:11: LangChainDeprecationWarning: The method `BaseTool.__call__` was deprecated in langchain-core 0.1.47 and will be removed in 1.0. Use :meth:`~invoke` instead.
    data = safe_dataframe_tool(query)

tests/test_agent.py::test_main_agent[line_3]
  /home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/kaleido/scopes/base.py:188: DeprecationWarning:
  
  setDaemon() is deprecated, set the daemon attribute instead

tests/test_agent.py: 24 warnings
  /home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/pipelines/chat/code_cleaning.py:520: DeprecationWarning:
  
  ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead

tests/test_agent.py: 24 warnings
  /usr/lib/python3.12/ast.py:587: DeprecationWarning:
  
  Attribute n is deprecated and will be removed in Python 3.14; use value instead

tests/test_agent.py::test_main_agent[line_15]
tests/test_agent.py::test_main_agent[line_45]
tests/test_agent.py::test_main_agent[line_45]
  <string>:3: UserWarning:
  
  Converting to PeriodArray/Index representation will drop timezone information.

tests/test_agent.py::test_main_agent[line_27]
tests/test_agent.py::test_main_agent[line_27]
tests/test_agent.py::test_main_agent[line_49]
tests/test_agent.py::test_main_agent[line_70]
tests/test_agent.py::test_main_agent[line_70]
tests/test_agent.py::test_main_agent[line_88]
  <string>:4: UserWarning:
  
  Converting to PeriodArray/Index representation will drop timezone information.

tests/test_agent.py::test_main_agent[line_31]
tests/test_agent.py::test_main_agent[line_31]
  <string>:2: SettingWithCopyWarning:
  
  
  A value is trying to be set on a copy of a slice from a DataFrame.
  Try using .loc[row_indexer,col_indexer] = value instead
  
  See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

tests/test_agent.py::test_main_agent[line_31]
tests/test_agent.py::test_main_agent[line_31]
tests/test_agent.py::test_main_agent[line_62]
tests/test_agent.py::test_main_agent[line_62]
tests/test_agent.py::test_main_agent[line_73]
tests/test_agent.py::test_main_agent[line_73]
  <string>:3: FutureWarning:
  
  'M' is deprecated and will be removed in a future version, please use 'ME' instead.

tests/test_agent.py::test_main_agent[line_83]
tests/test_agent.py::test_main_agent[line_85]
tests/test_agent.py::test_main_agent[line_88]
  /home/zcemg08/projects/chatbot/.chatbot_env/lib/python3.12/site-packages/pandasai/safe_libs/base_restricted_module.py:13: RuntimeWarning:
  
  More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
-------- generated xml file: /home/zcemg08/projects/chatbot/results.xml --------
=========================== short test summary info ============================
FAILED tests/test_agent.py::test_main_agent[line_5] - Failed: Failed: create ...
FAILED tests/test_agent.py::test_main_agent[line_13] - Failed: Failed: where ...
FAILED tests/test_agent.py::test_main_agent[line_20] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_27] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_45] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_49] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_51] - Failed: Failed: make b...
FAILED tests/test_agent.py::test_main_agent[line_70] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_76] - Failed: Failed: where ...
FAILED tests/test_agent.py::test_main_agent[line_83] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_88] - Failed: Failed: create...
FAILED tests/test_agent.py::test_main_agent[line_92] - Failed: Failed: where ...
FAILED tests/test_agent.py::test_main_agent[line_99] - Failed: Failed: where ...
FAILED tests/test_agent.py::test_main_agent[line_100] - Failed: Failed: where...
=========== 14 failed, 86 passed, 73 warnings in 1569.57s (0:26:09) ============
